name: Deploy Social BÃ­blia to VPS

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VPS_HOST: '31.97.85.98'
  VPS_USER: 'root'
  APP_DIR: '/opt/socialbiblia'

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Deploy to VPS
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ env.VPS_HOST }}
        username: ${{ env.VPS_USER }}
        password: ${{ secrets.VPS_PASSWORD }}
        port: 22
        timeout: 600s
        command_timeout: 600s
        script: |
          # FunÃ§Ã£o de log
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
          }
          
          # ====================================
          # ETAPA 1: PREPARAR AMBIENTE
          # ====================================
          log "ğŸš€ INICIANDO DEPLOY SOCIAL BÃBLIA - ETAPA 1: Preparando ambiente..."
          
          # ConfiguraÃ§Ãµes
          APP_DIR="${{ env.APP_DIR }}"
          REPO_URL="https://github.com/${{ github.repository }}.git"
          COMPOSE_PROJECT_NAME="socialbiblia"
          
          # Criar diretÃ³rio e navegar
          mkdir -p $APP_DIR
          cd $APP_DIR
          
          # Parar containers existentes ANTES de qualquer outra operaÃ§Ã£o
          log "â¹ï¸ Parando containers existentes..."
          if [ -f "docker-compose.production.yml" ]; then
            docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml down --remove-orphans || true
          fi
          
          # ====================================
          # ETAPA 2: BAIXAR/ATUALIZAR CÃ“DIGO
          # ====================================
          log "ğŸš€ ETAPA 2: Baixando cÃ³digo..."
          
          # Se nÃ£o existe repositÃ³rio, clonar
          if [ ! -d ".git" ]; then
            log "ğŸ“¥ Clonando repositÃ³rio..."
            git clone $REPO_URL . || {
              log "âŒ Clone falhou, usando download direto..."
              curl -L https://github.com/${{ github.repository }}/archive/main.tar.gz | tar xz --strip-components=1
            }
          else
            # Atualizar repositÃ³rio existente
            log "ğŸ”„ Atualizando repositÃ³rio..."
            git fetch origin && git reset --hard origin/main && git clean -fd
          fi
          
          # Verificar se baixou corretamente
          if [ ! -f "docker-compose.production.yml" ]; then
            log "âŒ Arquivo docker-compose.production.yml nÃ£o encontrado!"
            exit 1
          fi
          log "âœ… CÃ³digo baixado com sucesso"
          
          # ====================================
          # ETAPA 3: INSTALAR DEPENDÃŠNCIAS
          # ====================================
          log "ğŸš€ ETAPA 3: Verificando/instalando dependÃªncias..."
          
          # Atualizar sistema
          apt-get update -qq
          
          # Instalar Docker se necessÃ¡rio
          if ! command -v docker >/dev/null 2>&1; then
            log "ğŸ“¦ Instalando Docker..."
            curl -fsSL https://get.docker.com | sh
            systemctl start docker
            systemctl enable docker
          else
            log "âœ… Docker jÃ¡ instalado"
          fi
          
          # Verificar Docker Compose
          if ! docker compose version >/dev/null 2>&1; then
            log "ğŸ“¦ Instalando Docker Compose..."
            apt-get install -y docker-compose-plugin
          else
            log "âœ… Docker Compose jÃ¡ instalado"
          fi
          
          # Instalar Node.js se necessÃ¡rio (para builds locais se precisar)
          if ! command -v node >/dev/null 2>&1; then
            log "ğŸ“¦ Instalando Node.js..."
            curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
            apt-get install -y nodejs
          else
            log "âœ… Node.js jÃ¡ instalado"
          fi
          
          # ====================================
          # ETAPA 4: CONFIGURAR VARIÃVEIS DE AMBIENTE
          # ====================================
          log "ğŸš€ ETAPA 4: Configurando variÃ¡veis de ambiente..."
          
          # Criar arquivo .env se nÃ£o existir
          if [ ! -f ".env.production" ]; then
            log "ğŸ“ Criando arquivo .env.production..."
            cat > .env.production << EOF
          # ConfiguraÃ§Ãµes da aplicaÃ§Ã£o
          NODE_ENV=production
          APP_NAME=Social BÃ­blia
          
          # URLs base
          FRONTEND_URL=http://${{ env.VPS_HOST }}:3000
          BACKEND_URL=http://${{ env.VPS_HOST }}:4000
          
          # Banco de dados PostgreSQL
          DATABASE_URL=postgresql://socialbiblia_user:socialbiblia_secure_password@postgres:5432/socialbiblia_db
          POSTGRES_DB=socialbiblia_db
          POSTGRES_USER=socialbiblia_user
          POSTGRES_PASSWORD=socialbiblia_secure_password
          
          # JWT Secrets (gerados automaticamente)
          JWT_SECRET_USER=\$(openssl rand -base64 32)
          JWT_SECRET_ADMIN=\$(openssl rand -base64 32)
          JWT_SECRET_APP=\$(openssl rand -base64 32)
          JWT_EXPIRED_IN=24h
          
          # API Configuration
          API_PREFIX=api
          API_VERSION=v1
          
          # CORS Configuration
          CORS_ALLOW_ORIGIN=http://${{ env.VPS_HOST }}:3000
          
          # Bcrypt
          BCRYPT_SALTROUNDS=10
          
          # Rate Limiter
          RATE_LIMIT_MAX=1000
          RATE_LIMIT_WINDOW=15
          
          # Portas dos serviÃ§os
          WEB_PORT=3000
          API_PORT=4000
          POSTGRES_PORT=5432
          PGADMIN_PORT=8080
          
          # pgAdmin
          PGADMIN_DEFAULT_EMAIL=admin@socialbiblia.com
          PGADMIN_DEFAULT_PASSWORD=admin_socialbiblia_2024
          
          # Email (opcional - configurar depois se necessÃ¡rio)
          EMAIL_FROM=noreply@socialbiblia.com
          EMAIL_HOST=
          EMAIL_PORT=587
          EMAIL_USER=
          EMAIL_PASS=
          
          # Debug
          DEBUG_HTTP_REQUEST=false
          DEBUG_HTTP_CONNECTION=false
          EOF
            log "âœ… Arquivo .env.production criado"
          else
            log "âœ… Arquivo .env.production jÃ¡ existe"
          fi
          
          # ====================================
          # ETAPA 5: LIMPEZA PRÃ‰-BUILD
          # ====================================
          log "ğŸš€ ETAPA 5: Limpando ambiente..."
          
          # Limpar apenas containers do projeto atual (isolamento)
          docker compose -p $COMPOSE_PROJECT_NAME down --remove-orphans || true
          
          # Limpar imagens antigas apenas do projeto
          docker images --format "table {{.Repository}}:{{.Tag}}" | grep "socialbiblia" | awk '{print \$1}' | xargs -r docker rmi || true
          
          # Limpar volumes Ã³rfÃ£os apenas do projeto
          docker volume ls --format "{{.Name}}" | grep "socialbiblia" | xargs -r docker volume rm || true
          
          # ====================================
          # ETAPA 6: BUILD E DEPLOY
          # ====================================
          log "ğŸš€ ETAPA 6: Fazendo build e iniciando containers..."
          
          # Verificar estrutura necessÃ¡ria
          log "ğŸ” Verificando estrutura do projeto..."
          REQUIRED_FILES="docker-compose.production.yml docker/Dockerfile.api docker/Dockerfile.web apps/api/package.json apps/web/package.json packages/shared/package.json"
          for file in $REQUIRED_FILES; do
            if [ ! -f "$file" ]; then
              log "âŒ Arquivo obrigatÃ³rio nÃ£o encontrado: $file"
              ls -la $(dirname "$file")/
              exit 1
            else
              log "âœ… Encontrado: $file"
            fi
          done
          
          # Build e iniciar aplicaÃ§Ã£o com isolamento
          log "ğŸ”¨ Iniciando build dos containers..."
          docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml --env-file .env.production build --no-cache --progress=plain 2>&1 | tee build.log || {
            log "âŒ Falha no build dos containers!"
            log "ğŸ“‹ Ãšltimas linhas do build log:"
            tail -50 build.log
            exit 1
          }
          
          log "ğŸš€ Iniciando containers..."
          docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml --env-file .env.production up -d 2>&1 | tee startup.log || {
            log "âŒ Falha ao iniciar containers!"
            log "ğŸ“‹ Log de startup:"
            cat startup.log
            exit 1
          }
          
          # ====================================
          # ETAPA 7: CONFIGURAÃ‡ÃƒO DO BANCO
          # ====================================
          log "ğŸš€ ETAPA 7: Configurando banco de dados..."
          
          # Aguardar PostgreSQL iniciar
          log "â³ Aguardando PostgreSQL iniciar..."
          sleep 30
          
          # Aguardar API container estar rodando
          log "â³ Aguardando API container estar pronto..."
          timeout=300
          while [ $timeout -gt 0 ]; do
            # Verificar se container existe e estÃ¡ rodando
            container_status=$(docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml ps api --format "table {{.Service}}\t{{.State}}\t{{.Health}}" 2>/dev/null || echo "")
            log "ğŸ“Š Status API: $container_status"
            
            if echo "$container_status" | grep -q "running"; then
              log "âœ… API container estÃ¡ rodando"
              # Aguardar mais um pouco para o healthcheck
              sleep 20
              break
            fi
            log "â³ Aguardando... ($timeout segundos restantes)"
            sleep 15
            timeout=$((timeout - 15))
          done
          
          if [ $timeout -le 0 ]; then
            log "âŒ Timeout aguardando API container"
            log "ğŸ“‹ Status dos containers:"
            docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml ps
            log "ğŸ“‹ Logs da API:"
            docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml logs api --tail=50
            log "ğŸ“‹ Logs do PostgreSQL:"
            docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml logs postgres --tail=20
            exit 1
          fi
          
          # Executar migraÃ§Ãµes do Prisma
          log "ğŸ—ƒï¸ Executando migraÃ§Ãµes do banco..."
          docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml exec -T api npm run prisma:migrate:deploy || {
            log "âš ï¸ MigraÃ§Ãµes falharam, tentando gerar cliente Prisma..."
            docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml exec -T api npm run prisma:generate || true
          }
          
          # Seed inicial se necessÃ¡rio
          log "ğŸŒ± Executando seed do banco (se disponÃ­vel)..."
          docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml exec -T api npm run prisma:seed || log "âš ï¸ Seed nÃ£o disponÃ­vel ou falhou"
          
          # ====================================
          # ETAPA 8: VERIFICAÃ‡Ã•ES
          # ====================================
          log "ğŸš€ ETAPA 8: Verificando deployment..."
          
          # Aguardar todos os serviÃ§os iniciarem
          log "â³ Aguardando todos os serviÃ§os iniciarem..."
          sleep 60
          
          # Verificar status dos containers
          log "ğŸ“‹ Status dos containers:"
          docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml ps
          
          # Health checks bÃ¡sicos
          log "ğŸ¥ Executando health checks..."
          
          # Verificar se containers estÃ£o rodando
          FAILED_SERVICES=""
          
          EXPECTED_CONTAINERS="socialbiblia_web socialbiblia_api socialbiblia_postgres"
          for container in $EXPECTED_CONTAINERS; do
            if docker ps --format "{{.Names}}" | grep -q "$container"; then
              log "âœ… Container $container estÃ¡ rodando"
            else
              log "âŒ Container $container NÃƒO estÃ¡ rodando"
              FAILED_SERVICES="$FAILED_SERVICES $container"
            fi
          done
          
          # Testar endpoints bÃ¡sicos
          sleep 20
          
          # Test Frontend
          if curl -f http://localhost:3000 >/dev/null 2>&1; then
            log "âœ… Frontend (React): OK"
          else
            log "âŒ Frontend: FALHOU"
            FAILED_SERVICES="$FAILED_SERVICES frontend-health"
          fi
          
          # Test Backend API
          if curl -f http://localhost:4000/api >/dev/null 2>&1; then
            log "âœ… Backend API: OK"
          else
            log "âŒ Backend API: FALHOU"
            FAILED_SERVICES="$FAILED_SERVICES backend-health"
          fi
          
          # Test Database Connection via API
          if curl -f http://localhost:4000/api/info >/dev/null 2>&1; then
            log "âœ… Database Connection: OK"
          else
            log "âŒ Database Connection: FALHOU"
            FAILED_SERVICES="$FAILED_SERVICES database-health"
          fi
          
          # ====================================
          # ETAPA 9: CONFIGURAR PROXY/NGINX (SE NECESSÃRIO)
          # ====================================
          log "ğŸš€ ETAPA 9: Configurando acesso externo..."
          
          # Verificar se nginx estÃ¡ instalado no sistema
          if command -v nginx >/dev/null 2>&1; then
            log "ğŸ”§ Configurando Nginx para proxy reverso..."
            
            # Backup da configuraÃ§Ã£o existente
            cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.backup.\`date +%s\` || true
            
            # Criar configuraÃ§Ã£o do nginx para Social BÃ­blia
            cat > /etc/nginx/sites-available/socialbiblia << 'EOF'
          server {
              listen 80;
              server_name ${{ env.VPS_HOST }};
              
              # Frontend
              location / {
                  proxy_pass http://localhost:3000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
              
              # API Backend
              location /api {
                  proxy_pass http://localhost:4000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
          }
          EOF
            
            # Habilitar site
            ln -sf /etc/nginx/sites-available/socialbiblia /etc/nginx/sites-enabled/
            
            # Testar e recarregar nginx
            nginx -t && systemctl reload nginx && log "âœ… Nginx configurado com sucesso" || log "âš ï¸ Erro na configuraÃ§Ã£o do Nginx"
          else
            log "â„¹ï¸ Nginx nÃ£o instalado - aplicaÃ§Ã£o disponÃ­vel nas portas diretas"
          fi
          
          # ====================================
          # ETAPA 10: RESULTADO FINAL
          # ====================================
          if [ -n "$FAILED_SERVICES" ]; then
            log "âŒ DEPLOY COM PROBLEMAS. ServiÃ§os com falha:$FAILED_SERVICES"
            log "ğŸ“‹ Logs dos containers com problemas:"
            docker compose -p $COMPOSE_PROJECT_NAME -f docker-compose.production.yml logs --tail=50
            exit 1
          else
            log "ğŸ‰ DEPLOY DA SOCIAL BÃBLIA CONCLUÃDO COM SUCESSO!"
            log "ğŸŒ AplicaÃ§Ã£o disponÃ­vel em:"
            if command -v nginx >/dev/null 2>&1; then
              log "   - http://${{ env.VPS_HOST }} (AplicaÃ§Ã£o Principal - via Nginx)"
            fi
            log "   - http://${{ env.VPS_HOST }}:3000 (Frontend React - Direto)"
            log "   - http://${{ env.VPS_HOST }}:4000 (Backend API - Direto)"
            log "   - http://${{ env.VPS_HOST }}:8080 (pgAdmin - AdministraÃ§Ã£o BD)"
            log ""
            log "ğŸ” Credenciais pgAdmin:"
            log "   - Email: admin@socialbiblia.com"
            log "   - Senha: admin_socialbiblia_2024"
            log ""
            log "ğŸ“Š Resumo: $(docker ps --format '{{.Names}}' | grep socialbiblia | wc -l) containers ativos"
            log "ğŸ’¾ Banco: PostgreSQL rodando com isolamento"
            log "ğŸ”’ AplicaÃ§Ã£o isolada com Docker Compose"
            
            # Mostrar uso de recursos
            log "ğŸ“ˆ Uso de recursos:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" | head -10
          fi