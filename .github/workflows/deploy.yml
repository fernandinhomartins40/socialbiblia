name: üöÄ Deploy Biblicai to VPS

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  VPS_HOST: '31.97.85.98'
  VPS_USER: 'root'
  APP_DIR: '/opt/biblicai'
  COMPOSE_PROJECT_NAME: 'biblicai'

jobs:
  # ====================================
  # JOB 1: VALIDA√á√ÉO E BUILD LOCAL
  # ====================================
  validate-and-build:
    name: üîç Validate & Build
    runs-on: ubuntu-latest
    
    steps:
      - name: üì¶ Checkout code
        uses: actions/checkout@v4

      - name: üèóÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json
            apps/backend/package-lock.json

      - name: üîç Verify project structure
        run: |
          echo "üîç Verificando estrutura do projeto..."
          
          # Arquivos obrigat√≥rios para o novo setup
          REQUIRED_FILES=(
            "docker-compose.new.yml"
            "apps/backend/package.json"
            "apps/backend/tsconfig.json"
            "apps/backend/prisma/schema.prisma"
            "apps/backend/.env.ci"
            "apps/backend/src/app.ts"
            "apps/web/package.json"
            "apps/web/vite.config.ts"
            "configs/docker/Dockerfile.backend"
            "configs/docker/Dockerfile.web"
            ".env.production"
            "scripts/deploy-vps.sh"
          )
          
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "‚úÖ Found: $file"
            else
              echo "‚ùå Missing: $file"
              exit 1
            fi
          done
          
          echo "‚úÖ Estrutura do projeto validada"

      - name: üèóÔ∏è Install All Dependencies (Monorepo)
        run: |
          echo "üì¶ Instalando depend√™ncias do monorepo e workspaces..."
          # Instalar depend√™ncias do root e de todos os workspaces
          npm install --frozen-lockfile --ignore-scripts --no-fund --no-audit
          echo "‚úÖ Depend√™ncias do monorepo e workspaces instaladas"

      - name: üîß Setup CI Environment
        run: |
          echo "üîß Configurando ambiente CI..."
          cd apps/backend
          # Copy CI environment file
          cp .env.ci .env
          echo "‚úÖ Arquivo de ambiente CI configurado"

      - name: üîß Generate Prisma Client
        run: |
          echo "üóÉÔ∏è Gerando cliente Prisma..."
          cd apps/backend
          npx prisma generate
          echo "‚úÖ Cliente Prisma gerado"
          
      - name: üîç Validate Prisma Schema
        run: |
          echo "üîç Validando schema do Prisma..."
          cd apps/backend
          npx prisma validate
          echo "‚úÖ Schema do Prisma validado"

      - name: üèóÔ∏è Build Backend
        run: |
          echo "üî® Fazendo build do backend..."
          npm run build:backend
          echo "‚úÖ Build do backend conclu√≠do"

      - name: üèóÔ∏è Build Frontend
        run: |
          echo "üî® Fazendo build do frontend..."
          npm run build:web
          echo "‚úÖ Build do frontend conclu√≠do"

      - name: üß™ Validate TypeScript (Backend)
        run: |
          echo "üîç Validando TypeScript do backend..."
          cd apps/backend
          npx tsc --noEmit
          echo "‚úÖ TypeScript do backend validado"
          
      - name: üîç Validate API Structure
        run: |
          echo "üîç Validando estrutura da API..."
          cd apps/backend
          
          # Verificar arquivos cr√≠ticos das novas implementa√ß√µes
          CRITICAL_FILES=(
            "src/controllers/client/posts_controller.ts"
            "src/controllers/client/comments_controller.ts"
            "src/services/client/posts/index.ts"
            "src/services/client/comments/index.ts"
            "src/routes/client/v1/posts_route.ts"
            "src/routes/client/v1/comments_route.ts"
            "src/dao/posts/post_delete_dao.ts"
            "src/dao/comments/comment_create_dao.ts"
            "src/dao/comments/comment_get_all_dao.ts"
            "prisma/migrations/20250123_recommendations_system/migration.sql"
          )
          
          echo "Verificando arquivos cr√≠ticos das implementa√ß√µes..."
          for file in "${CRITICAL_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "‚úÖ Found: $file"
            else
              echo "‚ùå Missing critical file: $file"
              exit 1
            fi
          done
          
          echo "‚úÖ Estrutura da API validada"

      - name: üß™ Validate TypeScript (Frontend)
        run: |
          echo "üîç Validando TypeScript do frontend..."
          cd apps/web
          npm run typecheck
          echo "‚úÖ TypeScript do frontend validado"

  # ====================================
  # JOB 2: DEPLOY NA VPS
  # ====================================
  deploy:
    name: üöÄ Deploy to VPS
    runs-on: ubuntu-latest
    needs: validate-and-build
    
    steps:
      - name: üì¶ Checkout code
        uses: actions/checkout@v4

      - name: üöÄ Deploy to VPS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          port: 22
          timeout: 900s
          command_timeout: 900s
          script: |
            # Fun√ß√£o de log com timestamp
            log() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
            }
            
            # Configura√ß√µes
            APP_DIR="${{ env.APP_DIR }}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            COMPOSE_PROJECT_NAME="${{ env.COMPOSE_PROJECT_NAME }}"
            
            # ====================================
            # ETAPA 1: PREPARAR AMBIENTE
            # ====================================
            log "üöÄ INICIANDO DEPLOY BIBLICAI"
            log "Backend: Vincent Queimado Express + Prisma + TypeScript"
            log "Database: PostgreSQL"
            log "Frontend: React + Vite"
            
            # Criar diret√≥rio da aplica√ß√£o
            mkdir -p $APP_DIR
            cd $APP_DIR
            
            # Parar containers existentes
            log "‚èπÔ∏è Parando containers existentes..."
            docker compose -f docker-compose.new.yml down --remove-orphans 2>/dev/null || true
            
            # ====================================
            # ETAPA 2: ATUALIZAR C√ìDIGO
            # ====================================
            log "üì• Atualizando c√≥digo fonte..."
            
            if [ ! -d ".git" ]; then
              log "üì• Clonando reposit√≥rio..."
              git clone $REPO_URL . || {
                log "‚ùå Clone falhou, usando download direto..."
                curl -L https://github.com/${{ github.repository }}/archive/main.tar.gz | tar xz --strip-components=1
              }
            else
              log "üîÑ Atualizando reposit√≥rio existente..."
              git fetch origin && git reset --hard origin/main && git clean -fd
            fi
            
            # Verificar se arquivos essenciais existem
            REQUIRED_FILES="docker-compose.new.yml apps/backend/package.json apps/web/package.json configs/docker/Dockerfile.backend configs/docker/Dockerfile.web"
            for file in $REQUIRED_FILES; do
              if [ ! -f "$file" ]; then
                log "‚ùå Arquivo obrigat√≥rio n√£o encontrado: $file"
                ls -la $(dirname "$file")/
                exit 1
              fi
            done
            
            log "‚úÖ C√≥digo fonte atualizado com sucesso"
            
            # ====================================
            # ETAPA 3: INSTALAR DEPEND√äNCIAS DO SISTEMA
            # ====================================
            log "üîß Verificando depend√™ncias do sistema..."
            
            # Atualizar lista de pacotes
            apt-get update -qq
            
            # Instalar Docker se necess√°rio
            if ! command -v docker >/dev/null 2>&1; then
              log "üì¶ Instalando Docker..."
              curl -fsSL https://get.docker.com | sh
              systemctl start docker
              systemctl enable docker
              log "‚úÖ Docker instalado"
            else
              log "‚úÖ Docker j√° instalado ($(docker --version))"
            fi
            
            # Verificar Docker Compose
            if ! docker compose version >/dev/null 2>&1; then
              log "üì¶ Instalando Docker Compose..."
              apt-get install -y docker-compose-plugin
              log "‚úÖ Docker Compose instalado"
            else
              log "‚úÖ Docker Compose j√° instalado ($(docker compose version))"
            fi
            
            # Verificar se Docker est√° funcionando
            if ! docker info >/dev/null 2>&1; then
              log "‚ùå Docker n√£o est√° funcionando corretamente"
              systemctl restart docker
              sleep 10
              if ! docker info >/dev/null 2>&1; then
                log "‚ùå Falha cr√≠tica: Docker n√£o est√° funcionando"
                exit 1
              fi
            fi
            
            log "‚úÖ Todas as depend√™ncias do sistema verificadas"
            
            # ====================================
            # ETAPA 4: CONFIGURAR VARI√ÅVEIS DE AMBIENTE
            # ====================================
            log "üìù Configurando vari√°veis de ambiente..."
            
            # Copiar arquivo de produ√ß√£o se n√£o existir
            if [ ! -f ".env" ]; then
              if [ -f ".env.production" ]; then
                log "üìã Usando .env.production existente"
                cp .env.production .env
              else
                log "üìù Criando arquivo .env de produ√ß√£o..."
                cat > .env << 'EOF'
            # ==============================================
            # CONFIGURA√á√ïES DE PRODU√á√ÉO - BIBLICAI
            # Backend: Vincent Queimado Express + Prisma + TypeScript
            # ==============================================
            
            # Database Configuration (PostgreSQL)
            POSTGRES_DB=biblicai_db
            POSTGRES_USER=biblicai_user
            POSTGRES_PASSWORD=Biblicai@2024#SecureDB!VPS
            POSTGRES_PORT=5432
            DATABASE_URL=postgresql://biblicai_user:Biblicai@2024#SecureDB!VPS@postgres:5432/biblicai_db?schema=public
            
            # API Configuration (Vincent Queimado Backend)
            APP_URL_HOST=0.0.0.0
            APP_URL_PORT=3000
            SSL_ALLOW=false
            API_PREFIX=api
            API_JSON_LIMIT=5mb
            API_EXT_URLENCODED=false
            CORS_ALLOW_ORIGIN=*
            
            # JWT Configuration (Vincent Queimado Format)
            JWT_SECRET_USER=Biblicai@VincentQueimado#UserJWT2024!VPS#Secure
            JWT_SECRET_DEVICE=Biblicai@VincentQueimado#DeviceJWT2024!VPS#Secure
            JWT_EXPIRED_IN=24h
            
            # Security Configuration
            BCRYPT_SALTROUNDS=12
            RATE_LIMIT_MAX=500
            RATE_LIMIT_WINDOW=15
            
            # Debug Configuration (DISABLED IN PRODUCTION)
            DEBUG_HTTP_REQUEST=false
            DEBUG_HTTP_CONNECTION=false
            
            # Service Ports
            API_PORT=3000
            WEB_PORT=3000
            PGLADMIN_PORT=8080
            
            # pgAdmin Configuration
            PGLADMIN_DEFAULT_EMAIL=admin@biblicai.com.br
            PGLADMIN_DEFAULT_PASSWORD=Biblicai@Admin2024!VPS
            
            # Email Configuration (Optional)
            EMAIL_USER=admin@biblicai.com.br
            EMAIL_PASSWORD=
            EMAIL_SERVICE=gmail
            EMAIL_OAUTH_CLIENT_ID=
            EMAIL_OAUTH_CLIENT_SECRET=
            EMAIL_OAUTH_REFRESH_TOKEN=
            
            # Production Environment
            NODE_ENV=production
            TZ=America/Sao_Paulo
            COMPOSE_PROFILES=production
            EOF
              fi
            fi
            
            log "‚úÖ Vari√°veis de ambiente configuradas"
            
            # ====================================
            # ETAPA 5: DIAGN√ìSTICO DO SISTEMA
            # ====================================
            log "üîç Diagn√≥stico do sistema..."
            
            log "üíæ Recursos dispon√≠veis:"
            echo "  Memory: $(free -h | grep '^Mem:' | awk '{print $3"/"$2" ("$5")"}')"
            echo "  Disk: $(df -h / | tail -1 | awk '{print $3"/"$2" ("$5" used)"}')"
            echo "  Load: $(uptime | sed 's/.*load average: //')"
            
            log "üê≥ Docker Status:"
            docker --version
            docker compose version
            docker system df
            
            log "üì¶ Containers existentes:"
            docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | head -10
            
            log "üîå Portas em uso:"
            netstat -tulpn | grep -E ':(3000|5432|8080) ' | head -5 || echo "  Portas principais livres"
            
            # ====================================
            # ETAPA 6: LIMPEZA AGRESSIVA PRE-BUILD
            # ====================================
            log "üßπ Limpando ambiente com limpeza agressiva..."
            
            # Parar containers do projeto
            docker compose -f docker-compose.new.yml down --remove-orphans 2>/dev/null || true
            
            # LIMPEZA AGRESSIVA: Remover containers conflitantes por nome
            log "üóëÔ∏è Removendo containers conflitantes..."
            for container_name in biblicai_postgres biblicai_api biblicai_web biblicai_nginx biblicai_pgadmin; do
              if docker ps -a --format "{{.Names}}" | grep -q "^${container_name}$"; then
                log "Removendo container conflitante: $container_name"
                docker rm -f $container_name 2>/dev/null || true
              fi
            done
            
            # Remover tamb√©m containers antigos socialbiblia (fallback)
            for container_name in socialbiblia_postgres socialbiblia_api socialbiblia_web socialbiblia_nginx socialbiblia_pgadmin; do
              if docker ps -a --format "{{.Names}}" | grep -q "^${container_name}$"; then
                log "Removendo container antigo: $container_name"
                docker rm -f $container_name 2>/dev/null || true
              fi
            done
            
            # Limpar imagens do projeto
            docker images --format "table {{.Repository}}:{{.Tag}}" | grep -E "(biblicai|socialbiblia|backend|web)" | awk '{print $1}' | xargs -r docker rmi -f 2>/dev/null || true
            
            # Limpar volumes √≥rf√£os do projeto
            docker volume ls --format "{{.Name}}" | grep -E "(biblicai|socialbiblia)" | xargs -r docker volume rm 2>/dev/null || true
            
            # Limpar networks √≥rf√£s
            docker network ls --format "{{.Name}}" | grep -E "(biblicai|socialbiblia)" | xargs -r docker network rm 2>/dev/null || true
            
            log "‚úÖ Ambiente limpo"
            
            # ====================================
            # ETAPA 7: BUILD E DEPLOY
            # ====================================
            log "üî® Iniciando build e deploy..."
            
            # Build das imagens
            log "üèóÔ∏è Fazendo build das imagens..."
            if ! docker compose -f docker-compose.new.yml build --no-cache --parallel; then
              log "‚ùå Falha no build das imagens!"
              docker system df
              exit 1
            fi
            
            log "‚úÖ Build das imagens conclu√≠do"
            
            # Iniciar servi√ßos
            log "üöÄ Iniciando servi√ßos..."
            if ! docker compose -f docker-compose.new.yml up -d; then
              log "‚ùå Falha ao iniciar servi√ßos!"
              docker compose -f docker-compose.new.yml logs
              exit 1
            fi
            
            log "‚úÖ Servi√ßos iniciados"
            
            # ====================================
            # ETAPA 8: AGUARDAR INICIALIZA√á√ÉO
            # ====================================
            log "‚è≥ Aguardando inicializa√ß√£o dos servi√ßos..."
            
            # Aguardar PostgreSQL
            log "üêò Aguardando PostgreSQL..."
            timeout=120
            while [ $timeout -gt 0 ]; do
              if docker compose -f docker-compose.new.yml exec -T postgres pg_isready -U biblicai_user -d biblicai_db >/dev/null 2>&1; then
                log "‚úÖ PostgreSQL pronto!"
                break
              fi
              sleep 2
              timeout=$((timeout - 2))
              if [ $((timeout % 20)) -eq 0 ]; then
                log "‚è≥ Aguardando PostgreSQL... ($timeout segundos restantes)"
              fi
            done
            
            if [ $timeout -le 0 ]; then
              log "‚ùå Timeout aguardando PostgreSQL"
              docker compose -f docker-compose.new.yml logs postgres
              exit 1
            fi
            
            # Executar migra√ß√µes do Prisma
            log "üóÉÔ∏è Executando migra√ß√µes do banco..."
            
            # Verificar se as migra√ß√µes existem
            log "üìã Verificando migra√ß√µes dispon√≠veis..."
            docker compose -f docker-compose.new.yml exec -T api npx prisma migrate status || log "‚ö†Ô∏è Status das migra√ß√µes n√£o p√¥de ser verificado"
            
            # Tentar deploy das migra√ß√µes
            if ! docker compose -f docker-compose.new.yml exec -T api npx prisma migrate deploy; then
              log "‚ö†Ô∏è Migra√ß√µes falharam na primeira tentativa, verificando causa..."
              
              # Verificar se o banco est√° acess√≠vel
              if ! docker compose -f docker-compose.new.yml exec -T postgres pg_isready -U biblicai_user -d biblicai_db; then
                log "‚ùå Banco n√£o est√° acess√≠vel para migra√ß√µes"
                exit 1
              fi
              
              # Verificar logs de erro
              log "üìã Logs do container API para diagn√≥stico:"
              docker compose -f docker-compose.new.yml logs api | tail -20
              
              log "‚ö†Ô∏è Tentando reset e nova migra√ß√£o..."
              docker compose -f docker-compose.new.yml exec -T api npx prisma migrate reset --force
              docker compose -f docker-compose.new.yml exec -T api npx prisma migrate deploy
            fi
            
            # Verificar se as novas tabelas foram criadas
            log "üîç Verificando tabelas criadas..."
            docker compose -f docker-compose.new.yml exec -T postgres psql -U biblicai_user -d biblicai_db -c "\\dt" | grep -E "(posts|comments|users|user_interactions|recommendation_scores)" || log "‚ö†Ô∏è Algumas tabelas podem n√£o ter sido criadas"
            
            # Executar seed (opcional)
            log "üå± Executando seed do banco..."
            docker compose -f docker-compose.new.yml exec -T api npm run prisma:seed || log "‚ö†Ô∏è Seed falhou ou j√° executado"
            
            # Aguardar API
            log "üîå Aguardando API..."
            timeout=120
            while [ $timeout -gt 0 ]; do
              if curl -f http://localhost:3000/api/info >/dev/null 2>&1; then
                log "‚úÖ API pronta!"
                break
              fi
              sleep 2
              timeout=$((timeout - 2))
              if [ $((timeout % 20)) -eq 0 ]; then
                log "‚è≥ Aguardando API... ($timeout segundos restantes)"
              fi
            done
            
            if [ $timeout -le 0 ]; then
              log "‚ùå Timeout aguardando API"
              docker compose -f docker-compose.new.yml logs api
              exit 1
            fi
            
            # Aguardar Frontend
            log "üåê Aguardando Frontend..."
            timeout=60
            while [ $timeout -gt 0 ]; do
              if curl -f http://localhost:3000 >/dev/null 2>&1; then
                log "‚úÖ Frontend pronto!"
                break
              fi
              sleep 2
              timeout=$((timeout - 2))
              if [ $((timeout % 10)) -eq 0 ]; then
                log "‚è≥ Aguardando Frontend... ($timeout segundos restantes)"
              fi
            done
            
            if [ $timeout -le 0 ]; then
              log "‚ùå Timeout aguardando Frontend"
              docker compose -f docker-compose.new.yml logs web
              exit 1
            fi
            
            # ====================================
            # ETAPA 9: VERIFICA√á√ïES FINAIS
            # ====================================
            log "üîç Executando verifica√ß√µes finais..."
            
            # Status dos containers
            log "üìä Status dos containers:"
            docker compose -f docker-compose.new.yml ps
            
            # Health checks
            HEALTH_ISSUES=""
            
            # Test API endpoints
            if curl -f http://localhost:3000/api/info >/dev/null 2>&1; then
              log "‚úÖ API Health Check: OK"
              
              # Test specific API endpoints for new features
              log "üîç Testando endpoints espec√≠ficos..."
              
              # Test posts feed endpoint
              if curl -f -H "Accept: application/json" http://localhost:3000/api/client/posts/feed >/dev/null 2>&1; then
                log "‚úÖ Posts Feed Endpoint: OK"
              else
                log "‚ö†Ô∏è Posts Feed Endpoint: N√£o acess√≠vel"
              fi
              
              # Test auth endpoints
              if curl -f -H "Accept: application/json" http://localhost:3000/api/client/auth/register >/dev/null 2>&1 || [ $? -eq 22 ]; then
                log "‚úÖ Auth Register Endpoint: OK (method not allowed √© esperado)"
              else
                log "‚ö†Ô∏è Auth Register Endpoint: Problemas de conectividade"
              fi
              
            else
              log "‚ùå API Health Check: FALHOU"
              HEALTH_ISSUES="api "
            fi
            
            # Test Frontend
            if curl -f http://localhost:3000 >/dev/null 2>&1; then
              log "‚úÖ Frontend Health Check: OK"
            else
              log "‚ùå Frontend Health Check: FALHOU"
              HEALTH_ISSUES="frontend "
            fi
            
            # Test pgAdmin
            if curl -f http://localhost:8080 >/dev/null 2>&1; then
              log "‚úÖ pgAdmin Health Check: OK"
            else
              log "‚ö†Ô∏è pgAdmin Health Check: Pode estar inicializando"
            fi
            
            # Verificar se containers est√£o rodando
            EXPECTED_CONTAINERS="biblicai_postgres biblicai_api biblicai_web"
            for container in $EXPECTED_CONTAINERS; do
              if docker ps --format "{{.Names}}" | grep -q "$container"; then
                log "‚úÖ Container $container: Rodando"
              else
                log "‚ùå Container $container: N√ÉO est√° rodando"
                HEALTH_ISSUES="$container "
              fi
            done
            
            # ====================================
            # ETAPA 10: RELAT√ìRIO DE STATUS FINAL
            # ====================================
            log "üìã GERANDO RELAT√ìRIO FINAL DE STATUS..."
            echo ""
            echo "==========================================="
            echo "üîç BIBLICAI DEPLOY STATUS REPORT"
            echo "==========================================="
            echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Health Issues: ${HEALTH_ISSUES:-NENHUM}"
            echo ""
            
            # Sistema
            echo "üìä SISTEMA:"
            echo "  Memory: $(free -h | grep '^Mem:' | awk '{print $3"/"$2}')"
            echo "  Disk: $(df -h / | tail -1 | awk '{print $3"/"$2}')"
            echo "  Load: $(uptime | sed 's/.*load average: //')"
            echo ""
            
            # Docker info
            echo "üê≥ DOCKER:"
            echo "  Version: $(docker --version | cut -d' ' -f3 | tr -d ',')"
            echo "  Compose: $(docker compose version | head -1 | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+')"
            echo ""
            
            # Containers Status
            echo "üì¶ CONTAINERS STATUS:"
            docker ps -a --format "{{.Names}} {{.Status}} {{.Ports}}" | grep biblicai | head -10 || echo "  Nenhum container biblicai encontrado"
            echo ""
            
            # Network and Volumes
            echo "üåê RESOURCES:"
            echo "  Networks: $(docker network ls --format '{{.Name}}' | grep biblicai | wc -l)"
            echo "  Volumes: $(docker volume ls --format '{{.Name}}' | grep biblicai | wc -l)"
            echo ""
            
            # Health checks detalhados
            echo "üîç HEALTH STATUS:"
                        if curl -f http://localhost:3000/api/info >/dev/null 2>&1; then
            echo "  ‚úÖ API (3000): Respondendo"
            api_response=$(curl -s http://localhost:3000/api/info 2>/dev/null | head -1)
              echo "     Response: ${api_response:0:50}..."
            else
              echo "  ‚ùå API (3000): N√£o responde"
            fi
            
            if curl -f http://localhost:3000 >/dev/null 2>&1; then
              echo "  ‚úÖ Frontend (3000): Respondendo"
            else
              echo "  ‚ùå Frontend (3000): N√£o responde"
            fi
            
            if curl -f http://localhost:8080 >/dev/null 2>&1; then
              echo "  ‚úÖ pgAdmin (8080): Respondendo"
            else
              echo "  ‚ö†Ô∏è pgAdmin (8080): N√£o responde (normal durante inicializa√ß√£o)"
            fi
            echo ""
            
            # Portas em uso
            echo "üîå PORTAS:"
            for port in 3000 5432 8080; do
              if netstat -tuln 2>/dev/null | grep -q ":$port "; then
                process=$(netstat -tulpn 2>/dev/null | grep ":$port " | head -1 | awk '{print $7}' | cut -d'/' -f2)
                echo "  Port $port: Em uso por ${process:-unknown}"
              else
                echo "  Port $port: Livre"
              fi
            done
            echo ""
            
            # Se h√° problemas, mostrar logs cr√≠ticos
            if [ -n "$HEALTH_ISSUES" ]; then
              echo "üìã LOGS CR√çTICOS (√∫ltimas 3 linhas por container):"
              for container in biblicai_postgres biblicai_api biblicai_web; do
                if docker ps -a --format "{{.Names}}" | grep -q "$container"; then
                  echo "--- $container ---"
                  docker logs $container 2>&1 | tail -3 2>/dev/null
                  echo ""
                fi
              done
            fi
            
            # Final integration test
            echo "üîó TESTE FINAL DE INTEGRA√á√ÉO:"
            if [ -z "$HEALTH_ISSUES" ]; then
              log "üß™ Executando teste de integra√ß√£o frontend-backend..."
              
              # Test if frontend can reach backend
              frontend_to_backend_test=$(docker compose -f docker-compose.new.yml exec -T web curl -f http://api:3000/api/info 2>/dev/null || echo "FAILED")
              if [ "$frontend_to_backend_test" != "FAILED" ]; then
                echo "  ‚úÖ Frontend consegue comunicar com Backend"
              else
                echo "  ‚ö†Ô∏è Frontend n√£o consegue comunicar com Backend (pode ser normal)"
              fi
              
              # Test external access
              external_test=$(curl -f http://localhost:3000/api/info 2>/dev/null || echo "FAILED")
              if [ "$external_test" != "FAILED" ]; then
                echo "  ‚úÖ API acess√≠vel externamente"
              else
                echo "  ‚ö†Ô∏è API n√£o acess√≠vel externamente"
              fi
            fi
            echo ""
            
            echo "==========================================="
            if [ -n "$HEALTH_ISSUES" ]; then
              echo "‚ùå DEPLOY FALHOU - Problemas: $HEALTH_ISSUES"
              echo "üèÅ FIM DO RELAT√ìRIO DE FALHA"
            else
              echo "‚úÖ DEPLOY BEM-SUCEDIDO"
              echo "üèÅ FIM DO RELAT√ìRIO DE SUCESSO"
            fi
            echo "==========================================="
            echo ""
            
            # ====================================
            # RESULTADO FINAL
            # ====================================
            if [ -n "$HEALTH_ISSUES" ]; then
              log "‚ùå DEPLOY CONCLU√çDO COM PROBLEMAS!"
              log "üîç Servi√ßos com problemas: $HEALTH_ISSUES"
              exit 1
            else
              log "üéâ DEPLOY DA BIBLICAI CONCLU√çDO COM SUCESSO!"
              log ""
              log "üåê APLICA√á√ÉO DISPON√çVEL EM:"
              log "   ‚úÖ Frontend (React):     http://${{ env.VPS_HOST }}:3000"
                          log "   ‚úÖ API (Vincent Q.):     http://${{ env.VPS_HOST }}:3000/api/"
            log "   ‚úÖ API Docs (Swagger):  http://${{ env.VPS_HOST }}:3000/api/docs"
              log "   ‚úÖ pgAdmin:             http://${{ env.VPS_HOST }}:8080"
              log ""
              log "üîß TECNOLOGIAS DEPLOYADAS:"
              log "   ‚Ä¢ Backend: Vincent Queimado Express + Prisma + TypeScript"
              log "   ‚Ä¢ Database: PostgreSQL 15"
              log "   ‚Ä¢ Frontend: React 18 + Vite"
              log "   ‚Ä¢ Container: Docker + Docker Compose"
              log ""
              log "üìä RESUMO:"
              log "   ‚Ä¢ Containers ativos: $(docker ps --format '{{.Names}}' | grep biblicai | wc -l)"
              log "   ‚Ä¢ Volumes: $(docker volume ls --format '{{.Name}}' | grep biblicai | wc -l)"
              log "   ‚Ä¢ Networks: $(docker network ls --format '{{.Name}}' | grep biblicai | wc -l)"
              log ""
              log "üíæ USO DE RECURSOS:"
              docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" | head -5
              log ""
              log "üöÄ DEPLOY FINALIZADO - APLICA√á√ÉO PRONTA PARA USO!"
            fi

  # ====================================
  # JOB 3: NOTIFICA√á√ÉO (OPCIONAL)
  # ====================================
  notify:
    name: üì¢ Notify
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
      - name: üì¢ Deploy Status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Deploy realizado com sucesso!"
            echo "üåê Biblicai dispon√≠vel em: http://${{ env.VPS_HOST }}:3000"
          else
            echo "‚ùå Deploy falhou!"
            exit 1
          fi